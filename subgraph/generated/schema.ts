// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ContractURIUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ContractURIUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ContractURIUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ContractURIUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ContractURIUpdated | null {
    return changetype<ContractURIUpdated | null>(
      store.get("ContractURIUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get prevURI(): string {
    let value = this.get("prevURI");
    return value!.toString();
  }

  set prevURI(value: string) {
    this.set("prevURI", Value.fromString(value));
  }

  get newURI(): string {
    let value = this.get("newURI");
    return value!.toString();
  }

  set newURI(value: string) {
    this.set("newURI", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PlatformFeeInfoUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PlatformFeeInfoUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PlatformFeeInfoUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PlatformFeeInfoUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PlatformFeeInfoUpdated | null {
    return changetype<PlatformFeeInfoUpdated | null>(
      store.get("PlatformFeeInfoUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get platformFeeRecipient(): Bytes {
    let value = this.get("platformFeeRecipient");
    return value!.toBytes();
  }

  set platformFeeRecipient(value: Bytes) {
    this.set("platformFeeRecipient", Value.fromBytes(value));
  }

  get platformFeeBps(): BigInt {
    let value = this.get("platformFeeBps");
    return value!.toBigInt();
  }

  set platformFeeBps(value: BigInt) {
    this.set("platformFeeBps", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PluginAdded extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PluginAdded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PluginAdded must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PluginAdded", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PluginAdded | null {
    return changetype<PluginAdded | null>(
      store.get("PluginAdded", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get functionSelector(): Bytes {
    let value = this.get("functionSelector");
    return value!.toBytes();
  }

  set functionSelector(value: Bytes) {
    this.set("functionSelector", Value.fromBytes(value));
  }

  get pluginAddress(): Bytes {
    let value = this.get("pluginAddress");
    return value!.toBytes();
  }

  set pluginAddress(value: Bytes) {
    this.set("pluginAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PluginRemoved extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PluginRemoved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PluginRemoved must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PluginRemoved", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PluginRemoved | null {
    return changetype<PluginRemoved | null>(
      store.get("PluginRemoved", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get functionSelector(): Bytes {
    let value = this.get("functionSelector");
    return value!.toBytes();
  }

  set functionSelector(value: Bytes) {
    this.set("functionSelector", Value.fromBytes(value));
  }

  get pluginAddress(): Bytes {
    let value = this.get("pluginAddress");
    return value!.toBytes();
  }

  set pluginAddress(value: Bytes) {
    this.set("pluginAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PluginSet extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PluginSet entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PluginSet must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PluginSet", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PluginSet | null {
    return changetype<PluginSet | null>(
      store.get("PluginSet", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get functionSelector(): Bytes {
    let value = this.get("functionSelector");
    return value!.toBytes();
  }

  set functionSelector(value: Bytes) {
    this.set("functionSelector", Value.fromBytes(value));
  }

  get functionSignature(): Bytes {
    let value = this.get("functionSignature");
    return value!.toBytes();
  }

  set functionSignature(value: Bytes) {
    this.set("functionSignature", Value.fromBytes(value));
  }

  get pluginAddress(): Bytes {
    let value = this.get("pluginAddress");
    return value!.toBytes();
  }

  set pluginAddress(value: Bytes) {
    this.set("pluginAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class PluginUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PluginUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PluginUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PluginUpdated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): PluginUpdated | null {
    return changetype<PluginUpdated | null>(
      store.get("PluginUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get functionSelector(): Bytes {
    let value = this.get("functionSelector");
    return value!.toBytes();
  }

  set functionSelector(value: Bytes) {
    this.set("functionSelector", Value.fromBytes(value));
  }

  get oldPluginAddress(): Bytes {
    let value = this.get("oldPluginAddress");
    return value!.toBytes();
  }

  set oldPluginAddress(value: Bytes) {
    this.set("oldPluginAddress", Value.fromBytes(value));
  }

  get newPluginAddress(): Bytes {
    let value = this.get("newPluginAddress");
    return value!.toBytes();
  }

  set newPluginAddress(value: Bytes) {
    this.set("newPluginAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class RoleAdminChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleAdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleAdminChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleAdminChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get("RoleAdminChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get previousAdminRole(): Bytes {
    let value = this.get("previousAdminRole");
    return value!.toBytes();
  }

  set previousAdminRole(value: Bytes) {
    this.set("previousAdminRole", Value.fromBytes(value));
  }

  get newAdminRole(): Bytes {
    let value = this.get("newAdminRole");
    return value!.toBytes();
  }

  set newAdminRole(value: Bytes) {
    this.set("newAdminRole", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class RoleGranted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleGranted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleGranted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleGranted", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): RoleGranted | null {
    return changetype<RoleGranted | null>(
      store.get("RoleGranted", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class RoleRevoked extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleRevoked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleRevoked must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleRevoked", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): RoleRevoked | null {
    return changetype<RoleRevoked | null>(
      store.get("RoleRevoked", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BuyerApprovedForListing extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save BuyerApprovedForListing entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BuyerApprovedForListing must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BuyerApprovedForListing", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): BuyerApprovedForListing | null {
    return changetype<BuyerApprovedForListing | null>(
      store.get("BuyerApprovedForListing", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get buyer(): Bytes {
    let value = this.get("buyer");
    return value!.toBytes();
  }

  set buyer(value: Bytes) {
    this.set("buyer", Value.fromBytes(value));
  }

  get approved(): boolean {
    let value = this.get("approved");
    return value!.toBoolean();
  }

  set approved(value: boolean) {
    this.set("approved", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CancelledListing extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelledListing entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CancelledListing must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelledListing", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CancelledListing | null {
    return changetype<CancelledListing | null>(
      store.get("CancelledListing", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingCreator(): Bytes {
    let value = this.get("listingCreator");
    return value!.toBytes();
  }

  set listingCreator(value: Bytes) {
    this.set("listingCreator", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CurrencyApprovedForListing extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save CurrencyApprovedForListing entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CurrencyApprovedForListing must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CurrencyApprovedForListing", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CurrencyApprovedForListing | null {
    return changetype<CurrencyApprovedForListing | null>(
      store.get("CurrencyApprovedForListing", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get currency(): Bytes {
    let value = this.get("currency");
    return value!.toBytes();
  }

  set currency(value: Bytes) {
    this.set("currency", Value.fromBytes(value));
  }

  get pricePerToken(): BigInt {
    let value = this.get("pricePerToken");
    return value!.toBigInt();
  }

  set pricePerToken(value: BigInt) {
    this.set("pricePerToken", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewListing extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewListing entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewListing must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewListing", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NewListing | null {
    return changetype<NewListing | null>(
      store.get("NewListing", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingCreator(): Bytes {
    let value = this.get("listingCreator");
    return value!.toBytes();
  }

  set listingCreator(value: Bytes) {
    this.set("listingCreator", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get listing_listingId(): BigInt {
    let value = this.get("listing_listingId");
    return value!.toBigInt();
  }

  set listing_listingId(value: BigInt) {
    this.set("listing_listingId", Value.fromBigInt(value));
  }

  get listing_listingCreator(): Bytes {
    let value = this.get("listing_listingCreator");
    return value!.toBytes();
  }

  set listing_listingCreator(value: Bytes) {
    this.set("listing_listingCreator", Value.fromBytes(value));
  }

  get listing_assetContract(): Bytes {
    let value = this.get("listing_assetContract");
    return value!.toBytes();
  }

  set listing_assetContract(value: Bytes) {
    this.set("listing_assetContract", Value.fromBytes(value));
  }

  get listing_tokenId(): BigInt {
    let value = this.get("listing_tokenId");
    return value!.toBigInt();
  }

  set listing_tokenId(value: BigInt) {
    this.set("listing_tokenId", Value.fromBigInt(value));
  }

  get listing_quantity(): BigInt {
    let value = this.get("listing_quantity");
    return value!.toBigInt();
  }

  set listing_quantity(value: BigInt) {
    this.set("listing_quantity", Value.fromBigInt(value));
  }

  get listing_currency(): Bytes {
    let value = this.get("listing_currency");
    return value!.toBytes();
  }

  set listing_currency(value: Bytes) {
    this.set("listing_currency", Value.fromBytes(value));
  }

  get listing_pricePerToken(): BigInt {
    let value = this.get("listing_pricePerToken");
    return value!.toBigInt();
  }

  set listing_pricePerToken(value: BigInt) {
    this.set("listing_pricePerToken", Value.fromBigInt(value));
  }

  get listing_startTimestamp(): BigInt {
    let value = this.get("listing_startTimestamp");
    return value!.toBigInt();
  }

  set listing_startTimestamp(value: BigInt) {
    this.set("listing_startTimestamp", Value.fromBigInt(value));
  }

  get listing_endTimestamp(): BigInt {
    let value = this.get("listing_endTimestamp");
    return value!.toBigInt();
  }

  set listing_endTimestamp(value: BigInt) {
    this.set("listing_endTimestamp", Value.fromBigInt(value));
  }

  get listing_reserved(): boolean {
    let value = this.get("listing_reserved");
    return value!.toBoolean();
  }

  set listing_reserved(value: boolean) {
    this.set("listing_reserved", Value.fromBoolean(value));
  }

  get listing_tokenType(): i32 {
    let value = this.get("listing_tokenType");
    return value!.toI32();
  }

  set listing_tokenType(value: i32) {
    this.set("listing_tokenType", Value.fromI32(value));
  }

  get listing_status(): i32 {
    let value = this.get("listing_status");
    return value!.toI32();
  }

  set listing_status(value: i32) {
    this.set("listing_status", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewSale extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewSale entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewSale must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewSale", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NewSale | null {
    return changetype<NewSale | null>(store.get("NewSale", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingCreator(): Bytes {
    let value = this.get("listingCreator");
    return value!.toBytes();
  }

  set listingCreator(value: Bytes) {
    this.set("listingCreator", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    return value!.toBigInt();
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get buyer(): Bytes {
    let value = this.get("buyer");
    return value!.toBytes();
  }

  set buyer(value: Bytes) {
    this.set("buyer", Value.fromBytes(value));
  }

  get quantityBought(): BigInt {
    let value = this.get("quantityBought");
    return value!.toBigInt();
  }

  set quantityBought(value: BigInt) {
    this.set("quantityBought", Value.fromBigInt(value));
  }

  get totalPricePaid(): BigInt {
    let value = this.get("totalPricePaid");
    return value!.toBigInt();
  }

  set totalPricePaid(value: BigInt) {
    this.set("totalPricePaid", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class UpdatedListing extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UpdatedListing entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type UpdatedListing must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdatedListing", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): UpdatedListing | null {
    return changetype<UpdatedListing | null>(
      store.get("UpdatedListing", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get listingCreator(): Bytes {
    let value = this.get("listingCreator");
    return value!.toBytes();
  }

  set listingCreator(value: Bytes) {
    this.set("listingCreator", Value.fromBytes(value));
  }

  get listingId(): BigInt {
    let value = this.get("listingId");
    return value!.toBigInt();
  }

  set listingId(value: BigInt) {
    this.set("listingId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get listing_listingId(): BigInt {
    let value = this.get("listing_listingId");
    return value!.toBigInt();
  }

  set listing_listingId(value: BigInt) {
    this.set("listing_listingId", Value.fromBigInt(value));
  }

  get listing_listingCreator(): Bytes {
    let value = this.get("listing_listingCreator");
    return value!.toBytes();
  }

  set listing_listingCreator(value: Bytes) {
    this.set("listing_listingCreator", Value.fromBytes(value));
  }

  get listing_assetContract(): Bytes {
    let value = this.get("listing_assetContract");
    return value!.toBytes();
  }

  set listing_assetContract(value: Bytes) {
    this.set("listing_assetContract", Value.fromBytes(value));
  }

  get listing_tokenId(): BigInt {
    let value = this.get("listing_tokenId");
    return value!.toBigInt();
  }

  set listing_tokenId(value: BigInt) {
    this.set("listing_tokenId", Value.fromBigInt(value));
  }

  get listing_quantity(): BigInt {
    let value = this.get("listing_quantity");
    return value!.toBigInt();
  }

  set listing_quantity(value: BigInt) {
    this.set("listing_quantity", Value.fromBigInt(value));
  }

  get listing_currency(): Bytes {
    let value = this.get("listing_currency");
    return value!.toBytes();
  }

  set listing_currency(value: Bytes) {
    this.set("listing_currency", Value.fromBytes(value));
  }

  get listing_pricePerToken(): BigInt {
    let value = this.get("listing_pricePerToken");
    return value!.toBigInt();
  }

  set listing_pricePerToken(value: BigInt) {
    this.set("listing_pricePerToken", Value.fromBigInt(value));
  }

  get listing_startTimestamp(): BigInt {
    let value = this.get("listing_startTimestamp");
    return value!.toBigInt();
  }

  set listing_startTimestamp(value: BigInt) {
    this.set("listing_startTimestamp", Value.fromBigInt(value));
  }

  get listing_endTimestamp(): BigInt {
    let value = this.get("listing_endTimestamp");
    return value!.toBigInt();
  }

  set listing_endTimestamp(value: BigInt) {
    this.set("listing_endTimestamp", Value.fromBigInt(value));
  }

  get listing_reserved(): boolean {
    let value = this.get("listing_reserved");
    return value!.toBoolean();
  }

  set listing_reserved(value: boolean) {
    this.set("listing_reserved", Value.fromBoolean(value));
  }

  get listing_tokenType(): i32 {
    let value = this.get("listing_tokenType");
    return value!.toI32();
  }

  set listing_tokenType(value: i32) {
    this.set("listing_tokenType", Value.fromI32(value));
  }

  get listing_status(): i32 {
    let value = this.get("listing_status");
    return value!.toI32();
  }

  set listing_status(value: i32) {
    this.set("listing_status", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AuctionClosed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AuctionClosed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AuctionClosed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AuctionClosed", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): AuctionClosed | null {
    return changetype<AuctionClosed | null>(
      store.get("AuctionClosed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    return value!.toBigInt();
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get closer(): Bytes {
    let value = this.get("closer");
    return value!.toBytes();
  }

  set closer(value: Bytes) {
    this.set("closer", Value.fromBytes(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    return value!.toBigInt();
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get auctionCreator(): Bytes {
    let value = this.get("auctionCreator");
    return value!.toBytes();
  }

  set auctionCreator(value: Bytes) {
    this.set("auctionCreator", Value.fromBytes(value));
  }

  get winningBidder(): Bytes {
    let value = this.get("winningBidder");
    return value!.toBytes();
  }

  set winningBidder(value: Bytes) {
    this.set("winningBidder", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CancelledAuction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelledAuction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CancelledAuction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelledAuction", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CancelledAuction | null {
    return changetype<CancelledAuction | null>(
      store.get("CancelledAuction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionCreator(): Bytes {
    let value = this.get("auctionCreator");
    return value!.toBytes();
  }

  set auctionCreator(value: Bytes) {
    this.set("auctionCreator", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    return value!.toBigInt();
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewAuction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewAuction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewAuction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewAuction", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NewAuction | null {
    return changetype<NewAuction | null>(
      store.get("NewAuction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionCreator(): Bytes {
    let value = this.get("auctionCreator");
    return value!.toBytes();
  }

  set auctionCreator(value: Bytes) {
    this.set("auctionCreator", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    return value!.toBigInt();
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get auction_auctionId(): BigInt {
    let value = this.get("auction_auctionId");
    return value!.toBigInt();
  }

  set auction_auctionId(value: BigInt) {
    this.set("auction_auctionId", Value.fromBigInt(value));
  }

  get auction_auctionCreator(): Bytes {
    let value = this.get("auction_auctionCreator");
    return value!.toBytes();
  }

  set auction_auctionCreator(value: Bytes) {
    this.set("auction_auctionCreator", Value.fromBytes(value));
  }

  get auction_assetContract(): Bytes {
    let value = this.get("auction_assetContract");
    return value!.toBytes();
  }

  set auction_assetContract(value: Bytes) {
    this.set("auction_assetContract", Value.fromBytes(value));
  }

  get auction_tokenId(): BigInt {
    let value = this.get("auction_tokenId");
    return value!.toBigInt();
  }

  set auction_tokenId(value: BigInt) {
    this.set("auction_tokenId", Value.fromBigInt(value));
  }

  get auction_quantity(): BigInt {
    let value = this.get("auction_quantity");
    return value!.toBigInt();
  }

  set auction_quantity(value: BigInt) {
    this.set("auction_quantity", Value.fromBigInt(value));
  }

  get auction_currency(): Bytes {
    let value = this.get("auction_currency");
    return value!.toBytes();
  }

  set auction_currency(value: Bytes) {
    this.set("auction_currency", Value.fromBytes(value));
  }

  get auction_minimumBidAmount(): BigInt {
    let value = this.get("auction_minimumBidAmount");
    return value!.toBigInt();
  }

  set auction_minimumBidAmount(value: BigInt) {
    this.set("auction_minimumBidAmount", Value.fromBigInt(value));
  }

  get auction_buyoutBidAmount(): BigInt {
    let value = this.get("auction_buyoutBidAmount");
    return value!.toBigInt();
  }

  set auction_buyoutBidAmount(value: BigInt) {
    this.set("auction_buyoutBidAmount", Value.fromBigInt(value));
  }

  get auction_timeBufferInSeconds(): BigInt {
    let value = this.get("auction_timeBufferInSeconds");
    return value!.toBigInt();
  }

  set auction_timeBufferInSeconds(value: BigInt) {
    this.set("auction_timeBufferInSeconds", Value.fromBigInt(value));
  }

  get auction_bidBufferBps(): BigInt {
    let value = this.get("auction_bidBufferBps");
    return value!.toBigInt();
  }

  set auction_bidBufferBps(value: BigInt) {
    this.set("auction_bidBufferBps", Value.fromBigInt(value));
  }

  get auction_startTimestamp(): BigInt {
    let value = this.get("auction_startTimestamp");
    return value!.toBigInt();
  }

  set auction_startTimestamp(value: BigInt) {
    this.set("auction_startTimestamp", Value.fromBigInt(value));
  }

  get auction_endTimestamp(): BigInt {
    let value = this.get("auction_endTimestamp");
    return value!.toBigInt();
  }

  set auction_endTimestamp(value: BigInt) {
    this.set("auction_endTimestamp", Value.fromBigInt(value));
  }

  get auction_tokenType(): i32 {
    let value = this.get("auction_tokenType");
    return value!.toI32();
  }

  set auction_tokenType(value: i32) {
    this.set("auction_tokenType", Value.fromI32(value));
  }

  get auction_status(): i32 {
    let value = this.get("auction_status");
    return value!.toI32();
  }

  set auction_status(value: i32) {
    this.set("auction_status", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewBid extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewBid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewBid must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewBid", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NewBid | null {
    return changetype<NewBid | null>(store.get("NewBid", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionId(): BigInt {
    let value = this.get("auctionId");
    return value!.toBigInt();
  }

  set auctionId(value: BigInt) {
    this.set("auctionId", Value.fromBigInt(value));
  }

  get bidder(): Bytes {
    let value = this.get("bidder");
    return value!.toBytes();
  }

  set bidder(value: Bytes) {
    this.set("bidder", Value.fromBytes(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get bidAmount(): BigInt {
    let value = this.get("bidAmount");
    return value!.toBigInt();
  }

  set bidAmount(value: BigInt) {
    this.set("bidAmount", Value.fromBigInt(value));
  }

  get auction_auctionId(): BigInt {
    let value = this.get("auction_auctionId");
    return value!.toBigInt();
  }

  set auction_auctionId(value: BigInt) {
    this.set("auction_auctionId", Value.fromBigInt(value));
  }

  get auction_auctionCreator(): Bytes {
    let value = this.get("auction_auctionCreator");
    return value!.toBytes();
  }

  set auction_auctionCreator(value: Bytes) {
    this.set("auction_auctionCreator", Value.fromBytes(value));
  }

  get auction_assetContract(): Bytes {
    let value = this.get("auction_assetContract");
    return value!.toBytes();
  }

  set auction_assetContract(value: Bytes) {
    this.set("auction_assetContract", Value.fromBytes(value));
  }

  get auction_tokenId(): BigInt {
    let value = this.get("auction_tokenId");
    return value!.toBigInt();
  }

  set auction_tokenId(value: BigInt) {
    this.set("auction_tokenId", Value.fromBigInt(value));
  }

  get auction_quantity(): BigInt {
    let value = this.get("auction_quantity");
    return value!.toBigInt();
  }

  set auction_quantity(value: BigInt) {
    this.set("auction_quantity", Value.fromBigInt(value));
  }

  get auction_currency(): Bytes {
    let value = this.get("auction_currency");
    return value!.toBytes();
  }

  set auction_currency(value: Bytes) {
    this.set("auction_currency", Value.fromBytes(value));
  }

  get auction_minimumBidAmount(): BigInt {
    let value = this.get("auction_minimumBidAmount");
    return value!.toBigInt();
  }

  set auction_minimumBidAmount(value: BigInt) {
    this.set("auction_minimumBidAmount", Value.fromBigInt(value));
  }

  get auction_buyoutBidAmount(): BigInt {
    let value = this.get("auction_buyoutBidAmount");
    return value!.toBigInt();
  }

  set auction_buyoutBidAmount(value: BigInt) {
    this.set("auction_buyoutBidAmount", Value.fromBigInt(value));
  }

  get auction_timeBufferInSeconds(): BigInt {
    let value = this.get("auction_timeBufferInSeconds");
    return value!.toBigInt();
  }

  set auction_timeBufferInSeconds(value: BigInt) {
    this.set("auction_timeBufferInSeconds", Value.fromBigInt(value));
  }

  get auction_bidBufferBps(): BigInt {
    let value = this.get("auction_bidBufferBps");
    return value!.toBigInt();
  }

  set auction_bidBufferBps(value: BigInt) {
    this.set("auction_bidBufferBps", Value.fromBigInt(value));
  }

  get auction_startTimestamp(): BigInt {
    let value = this.get("auction_startTimestamp");
    return value!.toBigInt();
  }

  set auction_startTimestamp(value: BigInt) {
    this.set("auction_startTimestamp", Value.fromBigInt(value));
  }

  get auction_endTimestamp(): BigInt {
    let value = this.get("auction_endTimestamp");
    return value!.toBigInt();
  }

  set auction_endTimestamp(value: BigInt) {
    this.set("auction_endTimestamp", Value.fromBigInt(value));
  }

  get auction_tokenType(): i32 {
    let value = this.get("auction_tokenType");
    return value!.toI32();
  }

  set auction_tokenType(value: i32) {
    this.set("auction_tokenType", Value.fromI32(value));
  }

  get auction_status(): i32 {
    let value = this.get("auction_status");
    return value!.toI32();
  }

  set auction_status(value: i32) {
    this.set("auction_status", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AcceptedOffer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AcceptedOffer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AcceptedOffer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AcceptedOffer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): AcceptedOffer | null {
    return changetype<AcceptedOffer | null>(
      store.get("AcceptedOffer", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get offeror(): Bytes {
    let value = this.get("offeror");
    return value!.toBytes();
  }

  set offeror(value: Bytes) {
    this.set("offeror", Value.fromBytes(value));
  }

  get offerId(): BigInt {
    let value = this.get("offerId");
    return value!.toBigInt();
  }

  set offerId(value: BigInt) {
    this.set("offerId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    return value!.toBigInt();
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get seller(): Bytes {
    let value = this.get("seller");
    return value!.toBytes();
  }

  set seller(value: Bytes) {
    this.set("seller", Value.fromBytes(value));
  }

  get quantityBought(): BigInt {
    let value = this.get("quantityBought");
    return value!.toBigInt();
  }

  set quantityBought(value: BigInt) {
    this.set("quantityBought", Value.fromBigInt(value));
  }

  get totalPricePaid(): BigInt {
    let value = this.get("totalPricePaid");
    return value!.toBigInt();
  }

  set totalPricePaid(value: BigInt) {
    this.set("totalPricePaid", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class CancelledOffer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CancelledOffer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type CancelledOffer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("CancelledOffer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): CancelledOffer | null {
    return changetype<CancelledOffer | null>(
      store.get("CancelledOffer", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get offeror(): Bytes {
    let value = this.get("offeror");
    return value!.toBytes();
  }

  set offeror(value: Bytes) {
    this.set("offeror", Value.fromBytes(value));
  }

  get offerId(): BigInt {
    let value = this.get("offerId");
    return value!.toBigInt();
  }

  set offerId(value: BigInt) {
    this.set("offerId", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NewOffer extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewOffer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NewOffer must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewOffer", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NewOffer | null {
    return changetype<NewOffer | null>(store.get("NewOffer", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get offeror(): Bytes {
    let value = this.get("offeror");
    return value!.toBytes();
  }

  set offeror(value: Bytes) {
    this.set("offeror", Value.fromBytes(value));
  }

  get offerId(): BigInt {
    let value = this.get("offerId");
    return value!.toBigInt();
  }

  set offerId(value: BigInt) {
    this.set("offerId", Value.fromBigInt(value));
  }

  get assetContract(): Bytes {
    let value = this.get("assetContract");
    return value!.toBytes();
  }

  set assetContract(value: Bytes) {
    this.set("assetContract", Value.fromBytes(value));
  }

  get offer_offerId(): BigInt {
    let value = this.get("offer_offerId");
    return value!.toBigInt();
  }

  set offer_offerId(value: BigInt) {
    this.set("offer_offerId", Value.fromBigInt(value));
  }

  get offer_offeror(): Bytes {
    let value = this.get("offer_offeror");
    return value!.toBytes();
  }

  set offer_offeror(value: Bytes) {
    this.set("offer_offeror", Value.fromBytes(value));
  }

  get offer_assetContract(): Bytes {
    let value = this.get("offer_assetContract");
    return value!.toBytes();
  }

  set offer_assetContract(value: Bytes) {
    this.set("offer_assetContract", Value.fromBytes(value));
  }

  get offer_tokenId(): BigInt {
    let value = this.get("offer_tokenId");
    return value!.toBigInt();
  }

  set offer_tokenId(value: BigInt) {
    this.set("offer_tokenId", Value.fromBigInt(value));
  }

  get offer_quantity(): BigInt {
    let value = this.get("offer_quantity");
    return value!.toBigInt();
  }

  set offer_quantity(value: BigInt) {
    this.set("offer_quantity", Value.fromBigInt(value));
  }

  get offer_currency(): Bytes {
    let value = this.get("offer_currency");
    return value!.toBytes();
  }

  set offer_currency(value: Bytes) {
    this.set("offer_currency", Value.fromBytes(value));
  }

  get offer_totalPrice(): BigInt {
    let value = this.get("offer_totalPrice");
    return value!.toBigInt();
  }

  set offer_totalPrice(value: BigInt) {
    this.set("offer_totalPrice", Value.fromBigInt(value));
  }

  get offer_expirationTimestamp(): BigInt {
    let value = this.get("offer_expirationTimestamp");
    return value!.toBigInt();
  }

  set offer_expirationTimestamp(value: BigInt) {
    this.set("offer_expirationTimestamp", Value.fromBigInt(value));
  }

  get offer_tokenType(): i32 {
    let value = this.get("offer_tokenType");
    return value!.toI32();
  }

  set offer_tokenType(value: i32) {
    this.set("offer_tokenType", Value.fromI32(value));
  }

  get offer_status(): i32 {
    let value = this.get("offer_status");
    return value!.toI32();
  }

  set offer_status(value: i32) {
    this.set("offer_status", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
